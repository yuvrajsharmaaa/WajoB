;; Standard library for TON FunC smart contracts
;; Official TON stdlib functions

;; Load functions
forall X -> tuple cons(X head, tuple tail) asm "CONS";
forall X -> (tuple, X) uncons(tuple list) asm "UNCONS";
forall X -> (tuple, (X, int)) list_next(tuple list) asm( -> 1 0) "UNCONS";
forall X -> X car(tuple list) asm "CAR";
tuple cdr(tuple list) asm "CDR";
tuple empty_tuple() asm "NIL";
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, X) tpop(tuple t) asm "TPOP";
int tuple_length(tuple t) asm "TLEN";
forall X -> X first(tuple t) asm "FIRST";
forall X -> X second(tuple t) asm "SECOND";
forall X -> X third(tuple t) asm "THIRD";
forall X -> X fourth(tuple t) asm "FOURTH";
forall X, Y -> [X, Y] pair_first(X x, Y y) asm "PAIR";
forall X, Y -> [X, Y] pair_second(X x, Y y) asm "PAIR";
forall X -> X unsingle([X] t) asm "UNSINGLE";
forall X, Y -> (X, Y) unpair([X, Y] t) asm "UNPAIR";
forall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm "UNTRIPLE";
forall X, Y, Z, W -> (X, Y, Z, W) unquadruple([X, Y, Z, W] t) asm "UNQUADRUPLE";
tuple empty_list() asm "NIL";

;; Cell primitives
int null?(cell c) asm "ISNULL";
() set_data(cell c) impure asm "c4 PUSH";
cell get_data() asm "c4 PUSH";
cont get_c3() impure asm "c3 PUSH";
() set_c3(cont c) impure asm "c3 POP";
cont bless(slice s) impure asm "BLESS";

;; Slice primitives
int slice_refs(slice s) asm "SREFS";
int slice_bits(slice s) asm "SBITS";
int slice_empty?(slice s) asm "SEMPTY";
int slice_data_empty?(slice s) asm "SDEMPTY";
int slice_refs_empty?(slice s) asm "SREMPTY";
int slice_depth(slice s) asm "SDEPTH";

;; Builder primitives  
int builder_refs(builder b) asm "BREFS";
int builder_bits(builder b) asm "BBITS";
int builder_depth(builder b) asm "BDEPTH";

;; Cell operations
cell begin_cell() asm "NEWC";
cell end_cell(builder b) asm "ENDC";
builder store_ref(builder b, cell c) asm(c b) "STREF";
builder store_uint(builder b, int x, int len) asm(x b len) "STUX";
builder store_int(builder b, int x, int len) asm(x b len) "STIX";
builder store_slice(builder b, slice s) asm "STSLICER";
builder store_grams(builder b, int x) asm "STGRAMS";
builder store_coins(builder b, int x) asm "STGRAMS";
builder store_dict(builder b, cell c) asm(c b) "STDICT";

;; Slice operations
slice begin_parse(cell c) asm "CTOS";
(slice, cell) load_ref(slice s) asm( -> 1 0) "LDREF";
(slice, int) load_uint(slice s, int len) asm(s len -> 1 0) "LDUX";
(slice, int) load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
(slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX";
(slice, int) load_grams(slice s) asm( -> 1 0) "LDGRAMS";
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";
(slice, cell) load_dict(slice s) asm( -> 1 0) "LDDICT";

;; Slice operations continuation
slice preload_ref(slice s) asm "PLDREF";
int preload_uint(slice s, int len) asm "PLDUX";
int preload_int(slice s, int len) asm "PLDIX";
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";

;; Address operations
slice store_msg_addr(builder b, slice addr) asm(addr b) "STSLICER";
(slice, slice) load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";

;; Dictionary operations
(cell, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
(cell, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(cell, cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF";
(cell, cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETREF";

(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";

(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";
(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDEL";

;; Math operations
int min(int x, int y) asm "MIN";
int max(int x, int y) asm "MAX";
(int, int) minmax(int x, int y) asm "MINMAX";
int abs(int x) asm "ABS";

;; Logical operations
int equal_slices(slice a, slice b) asm "SDEQ";
int builder_null?(builder b) asm "ISNULL";
int cell_null?(cell c) asm "ISNULL";
int slice_null?(slice s) asm "ISNULL";

;; Hashing
int slice_hash(slice s) asm "HASHSU";
int string_hash(slice s) asm "SHA256U";
int cell_hash(cell c) asm "HASHCU";

;; Time
int now() asm "NOW";
int my_address() asm "MYADDR";
int cur_lt() asm "LTIME";
int block_lt() asm "BLOCKLT";

;; Send message
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";

;; Random
int random() impure asm "RANDU256";
int rand(int range) impure asm "RAND";
int get_seed() impure asm "RANDSEED";
int set_seed(int seed) impure asm "SETRAND";
() randomize(int x) impure asm "ADDRAND";
() randomize_lt() impure asm "LTIME" "ADDRAND";

;; Math extended
int muldiv(int a, int b, int c) asm "MULDIV";
int muldivr(int a, int b, int c) asm "MULDIVR";
int muldivc(int a, int b, int c) asm "MULDIVC";

;; Exceptions
() throw(int exc_no) impure asm "THROW";
() throw_if(int exc_no, int cond) impure asm "THROWIF";
() throw_unless(int exc_no, int cond) impure asm "THROWIFNOT";

;; Debug
() dump_stack() impure asm "DUMPSTK";

;; Gas
int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNU";
int check_data_signature(slice data, slice signature, int public_key) asm "CHKSIGNS";

;; Config
cell config_param(int x) asm "CONFIGOPTPARAM";
int cell_hash(cell c) asm "HASHCU";
int slice_hash(slice s) asm "HASHSU";
int string_hash(slice s) asm "SHA256U";

() accept_message() impure asm "ACCEPT";
() set_gas_limit(int limit) impure asm "SETGASLIMIT";
() commit() impure asm "COMMIT";
() buy_gas(int gram) impure asm "BUYGAS";

int get_balance() asm "BALANCE" "FIRST";
[int, cell] get_balance_ex() asm "BALANCE";
